\chapter{Выполнение задания}

В ходе выполнения домашнего задания реализуется алгоритм Бойера --- Мура поиска подстроки в
строке (поиск одной и той же подстроки в файле от 100 Мбайт).
Для данного алгоритма рассматриваются следующие графовые модели: операционный граф, информационный граф, граф операционной истории, граф информационной истории. Далее рассматривается возможность распараллеливания алгоритма.
Далее следуют определения, необходимые для составления разрабатываемых графов.


Операционное отношение: две вершины A и B соединяются направленной дугой тогда и только тогда, когда вершина B может быть выполнена сразу после вершины A.


Информационное отношение: Две вершины A и B соединяются направленной дугой тогда и только тогда, когда вершина B использует в
качестве аргумента некоторое значение, полученное в вершине A.


Операционная история: вершины это срабатывания операторов, а дуги -- операционное отношение.
Информационная история: вершины это срабатывания операторов, а дуги -- информационное отношение.
\section{Средства реализации}

В качестве языка программирования для реализации данной лабораторной работы был выбран язык программирования Python. Выбор обусловлен наличием библиотек для измерения времени, наличием инструментов для работы с параллельными потоками. Были использованы библиотеки threading, multiprocessing, os.

\section{Программный код}

В листингах \ref{lst:lev_mat}, \ref{lst:dlev_rec}, \ref{lst:dlev_mat} приведена реализация алгоритма Бойера --- Мура поиска подстроки в
строке.
\newpage
\begin{lstlisting}[label=lst:lev_mat,caption=Алгоритм Бойера--Мура поиска подстроки в строке.]
def bouer_moor():
	text = input()									  #text
	pattern = input()								  #pattern
	bad_char = bad_char_heuristic(pattern)            #1
	good_suffix = good_suffix_heuristic(pattern)      #2
	i = 0										      #3
	indexes = []									  #4
	while i <= len(text) - len(pattern):              #5
		j = len(pattern) - 1                          #6
		while j >= 0 and pattern[j] == text[i + j]:   #7
			j -= 1                                    #8
		if j < 0:                                     #9
			indexes.append(i)                         #10
			i += good_suffix[0]                       #11
		else:                                         #12
			x = j - bad_char.get(text[i + j], -1)     #13
			y = good_suffix[j + 1]                    #14
			i += max(x, y)                            #15
	return indexes                                    
	
\end{lstlisting}
\newpage
\begin{lstlisting}[label=lst:dlev_rec,caption= Эвристика хорошего суффикса]
def good_suffix_heuristic(pattern):
	good_suffix = [-1] * (len(pattern) + 1)
	border = [0] * (len(pattern) + 1)
	i = len(pattern)
	j = len(pattern) + 1
	border[i] = j
	while i > 0:
		while j <= len(pattern) and pattern[i - 1] != pattern[j - 1]:
			if good_suffix[j] == 0:
				good_suffix[j] = j - i
			j = border[j]
		i -= 1
		j -= 1
		border[i] = j
	j = border[0]
	for i in range(len(pattern) + 1):
		if good_suffix[i] == -1:
			good_suffix[i] = j
		if i == j:
			j = border[j]
	return good_suffix
\end{lstlisting}
\newpage
\begin{lstlisting}[label=lst:dlev_mat,caption=Эвристика плохого символа]
def bad_char_heuristic(pattern):
	bad_char = {}
	for i in range(len(pattern)):
		bad_char[pattern[i]] = i
	return bad_char
\end{lstlisting}
\newpage


\section{Графовые представления}

На рисунке \ref{svgimg:diag-Page-1} представлен операционный граф для алгоритма Бойера--Мура поиска подстроки в строке.

На рисунке \ref{svgimg:diag-Page-2} представлен информационный граф для этого же алгоритма.

На рисунке \ref{svgimg:diag-Page-4} представлен граф операционной истории, на рисунке \ref{svgimg:diag-Page-4} представлен граф информационной истории.
\svgimg{90mm}{diag-Page-1}{Операционный граф}
\newpage
\svgimg{100mm}{diag-Page-2}{Информационный граф}
\newpage
\svgimg{70mm}{diag-Page-4}{Граф операционной истории рассматриваемого алгормтма при исходном тексте, состоящем только из искомого паттерна}
\newpage
\svgimg{120mm}{diag-Page-3}{Граф информационной истории}
\newpage
\section{К разработке параллельного алгоритма Бойера --- Мура}
Так как при работе алгоритма отступ после каждого сравнения может быть рассчитан только после нахождения несоответствия в тексте, был выбран подход разделения текста, в котором происходит поиск паттерна, на равные части. 
Вычисление результата для каждой части будет независим от вычисления результата других частей. При ситуации, где разделение текста происходит на паттерне, выбран подход, где параллельный процесс с собственной частью может получить доступ к следующей за ней части текста ровно на размер строки паттерна.