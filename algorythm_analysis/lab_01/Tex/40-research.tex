\chapter{Исследовательская часть}

В данном разделе будут приведены примеры работы программ, постановка эксперимента и сравнительный анализ алгоритмов на основе полученных данных.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item Операционная система: 64-разрядная операционная система, процессор x64.
	\item Память: 16 Гб.
	\item Процессор: Intel(R) Core(TM) i7--4700HQ CPU @ 2.40 ГГц.
\end{itemize}

Во время тестирования ноутбук был нагружен только встроенными приложениями окружения, а также непосредственно системой тестирования.

\section{Время выполнения алгоритмов}

Алгоритмы тестировались при помощи функции process\_time() из библиотеки time языка Python. Данная функция возвращает сумму системного и пользовательского процессорного времени текущего процессора, типа float в секундах.

Замеры времени для каждой длины слов проводились 100 раз. В качестве результата взято среднее время работы алгоритма.

Результаты замеров приведены в таблице \ref{tab:time} (время в мкс).

\begin{table}[!ht]
	\captionsetup{singlelinecheck=off}
		\caption{\raggedright\label{tab:time}Результаты замеров времени.}
		\begin{tabular}{|c|p{3cm}|p{3cm}|p{3cm}|p{3cm}|
			}
			
			\hline
			Длина & Левенштейн    (матрица)& Дамерау--Левенштейн     (матрица)& Дамерау--Левенштейн  (рекурсия) & Дамерау--Левенштейн  (рекурсия + кеш)  \\
			\hline
			0 & 0.000000 & 0.000000 & 0.000000 & 0.000000  \\
			\hline
			1 & 0.000000 & 0.000000 & 0.000000 & 0.000000 \\
			\hline
			2 & 0.000000 & 0.000000 & 0.000000 & 0.000000 \\
			\hline
			3 & 0.000000 & 0.000000 & 0.000000 & 0.000000 \\
			\hline
			4 & 0.000000 & 0.000000 & 312.5 & 0.000000 \\
			\hline
			5 & 0.000000 & 0.000000 & 1250.0 & 156.25 \\
			\hline
			6 & 0.000000 & 0.000000 & 6093.75 & 156.25 \\
			\hline
			7 & 156.25 & 132.745 & 32656.25 & 312.5 \\ 
			\hline
		\end{tabular}
\end{table}

\img{120mm}{time}{Временные затраты алгоритмов}

\section{Использование памяти}
% ИЗМЕНИТЬ - НА ТИРЕ
Пусть длина строки S1 -- n, длина строки S2 -- m, тогда затраты памяти на приведенные выше алгоритмы будут следующими:
\newpage
\begin{itemize}
	\item матричный алгоритм поиска расстояния Левенштейна, Дамерау -- Левенштейна:\begin{itemize}
		\item строки S1, S2 - (m + n) * sizeof(char)
		\item матрица -- ((m + 1) * (n + 1)) * sizeof(int)
		\item длины строк -- 2 * sizeof(int)
		\item вспомогательные переменные --  3 * sizeof(int)
	\end{itemize}
\end{itemize}

Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящий строк.

\begin{itemize}
	\item рекурсивный алгоритм поиска расстояния Дамерау -- Левенштейна(для каждого вызова):
	\begin{itemize}
		\item строки S1, S2 -- (m + n) * sizeof(char)
		\item длины строк -- 2 * sizeof(int)
		\item вспомогательная переменная -  sizeof(int)
		\item адрес возврата
	\end{itemize}
	\item рекурсивный алгоритм поиска расстояния Дамерау -- Левенштейна с использованием кеша (для каждого вызова): Для всех вызовов еще память для хранения самой матрицы -  ((m + 1) * (n + 1)) * sizeof(int) \begin{itemize}
		\item строки S1, S2 -- (m + n) * sizeof(char)
		\item длины строк -- 2 * sizeof(int)
		\item вспомогательные переменные --  5 * sizeof(int)
		\item ссылка на матрицу -- 8 байт
		\item адрес возврата
	\end{itemize}
\end{itemize}


\section*{Вывод}

Рекурсивный алгоритм нахождения расстояния Дамерау - Левенштейна работает на порядок дольше итеративных реализаций, время его работы увеличивается в геометрической прогрессии. На словах длиной 7 символов, матричная реализация алгоритма нахождения расстояния Левенштейна превосходит по времени работы рекурсивную на несколько порядков.

Рекурсивный алгоритм с заполнением матрицы превосходит простой рекурсивный и сравним по времени работы с матричными алгоритмами. 

Алгоритм нахождения расстояния Дамерау — Левенштейна по времени выполнения сопоставим с алгоритмом нахождения расстояния Левенштейна. В нём добавлена дополнительная проверка, позволяющая находить ошибки пользователя, связанные с неверным порядком букв, в связи с чем он работает незначительно дольше, чем алгоритм нахождения расстояния Левенштейна.

Но по расходу памяти итеративные алгоритмы проигрывают рекурсивному: максимальный размер используемой памяти в них растёт как произведение длин строк, в то время как у рекурсивного алгоритма — как сумма длин строк.
