\chapter{Исследовательская часть}

В данном разделе будет приведена постановка замера времени и сравнительный анализ алгоритмов на основе полученных данных.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялся замер времени:

Операционная система: 64-разрядная операционная система, процессор x64.


Память: 16 Гб.


Процессор: Intel(R) Core(TM) i7--4700HQ CPU @ 2.40 ГГц.


Во время замера времени ноутбук был нагружен только встроенными приложениями окружения, а также непосредственно системой тестирования.

\section{Время выполнения алгоритмов}

Алгоритмы замерялись при помощи функции $time.perf\_counter()$ из библиотеки $time$ языка $Python$. Данная функция возвращает значение в долях секунды счетчика производительности, то есть часов с наибольшим доступным разрешением для измерения короткой длительности.

Замеры времени для каждого выполнения проводились 100000 раз. В качестве результата взято среднее время работы алгоритма.

\begin{table}[h!]
	\captionsetup{singlelinecheck=off}\caption{\raggedright\label{tabular:time1} Замеры времени при нахождении элемента в массиве}
	\begin{center}
		\begin{tabular}{c@{\hspace{7mm}}c@{\hspace{5mm}}c@{\hspace{7mm}}c@{\hspace{7mm}}}
			\hline
			Кол-во элементов & AVL-дерево(ns) & Бинарный поиск(ns) \\ \hline
			\vspace{4mm}
			$
			128
			$ &
			$
			 952.03200
			$ &
			$
			2.43218
			$ \\
			\vspace{4mm}
			$
			256
			$ &
			$
			1020.54900
			
			$ &
			$
			 2.67411
			$ \\
			\vspace{4mm}
			$
			512
			$ &
			$
			1464.10500
			$ &
			$
			2.99134
			$ \\
			\vspace{4mm}
			$
			1024
			$ &
			$
			1673.71200
			$ &
			$
			3.51576
			$\\
			\vspace{4mm}
			$
			2048
			$ &
			$
			1743.52000
			$ &
			$
			3.62115
			$ \\
			\vspace{4mm}
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h!]
	\captionsetup{singlelinecheck=off}\caption{\raggedright\label{tabular:time2} Замеры времени при отсутствии элемента в массиве}
	\begin{center}
		\begin{tabular}{c@{\hspace{7mm}}c@{\hspace{5mm}}c@{\hspace{7mm}}c@{\hspace{7mm}}}
			\hline
			Кол-во элементов & AVL-дерево(ns) & Бинарный поиск(ns) \\ \hline
			\vspace{4mm}
			$
			128
			$ &
			$
			763.34930
			$ &
			$
			2.32894
			$ \\
			\vspace{4mm}
			$
			256
			$ &
			$
			1007.96921
			$ &
			$
			3.56399
			$ \\
			\vspace{4mm}
			$
			512
			$ &
			$
			1686.90563
			$ &
			$
			3.95372
			$ \\
			\vspace{4mm}
			$
			1024
			$ &
			$
			1950.73587
			$ &
			$
			5.04567
			$\\
			\vspace{4mm}
			$
			2048
			$ &
			$
			2137.42351
			$ &
			$
			6.51642
			$ \\
			\vspace{4mm}
		\end{tabular}
	\end{center}
\end{table}

Из таблицы \ref{tabular:time1} можно сделать вывод, что бинарный поиск затрачивает меньше времени в 500 раз. 
Поиск по AVL-дереву и бинарный поиск требуют подготовки данных. 
Для первого алгоритма должно быть построено бинарное сбалансированное дерево, для бинарного поиска массив должен быть изначально отсортирован.


Лучшим случаем при нахождении элемента является его нахождение в корне AVL--дерева, или же в середине массива для бинарного поиска.
Лучшим случаем при отсутствии элемента является выявление его отсутствия при втором сравнении элементов во время выполнения алгоритма.


Худшим случаем при нахождении элемента является его нахождение на максимальной высоте AVL--дерева или на грани массива. 
Худшим случаем при отсутствии элемента является прохождение всей ветви AVL--дерева или же всех сравнений при бинарном поиске т.е. элемент должен быть за гранью разброса величин, находящихся в массиве.


При лучших случаях с нахождением элемента, логично, будет произведено только одно сравнение.
При лучших случаях с отсутствием элемента будет произведено 5 сравнений.
\begin{table}[h!]
	\captionsetup{singlelinecheck=off}\caption{\raggedright\label{tabular:sr2} Количество сравнений элементов худший случай при нахождении элемента}
	\begin{center}
		\begin{tabular}{c@{\hspace{7mm}}c@{\hspace{5mm}}c@{\hspace{7mm}}c@{\hspace{7mm}}}
			\hline
			Кол-во элементов & AVL-дерево & Бинарный поиск \\ \hline
			\vspace{4mm}
			$
			128
			$ &
			$
			22
			$ &
			$
			19
			$ \\
			\vspace{4mm}
			$
			256
			$ &
			$
			25
			$ &
			$
			22
			$ \\
			\vspace{4mm}
			$
			512
			$ &
			$
			28
			$ &
			$
			25
			$ \\
			\vspace{4mm}
			$
			1024
			$ &
			$
			31
			$ &
			$
			28
			$\\
			\vspace{4mm}
			$
			2048
			$ &
			$
			34
			$ &
			$
			31
			$ \\
			\vspace{4mm}
		\end{tabular}
	\end{center}
\end{table}


\begin{table}[h!]
	\captionsetup{singlelinecheck=off}\caption{\raggedright\label{tabular:sr3} Количество сравнений элементов худший случай при отсутствии элемента}
	\begin{center}
		\begin{tabular}{c@{\hspace{7mm}}c@{\hspace{5mm}}c@{\hspace{7mm}}c@{\hspace{7mm}}}
			\hline
			Кол-во элементов & AVL-дерево & Бинарный поиск\\ \hline
			\vspace{4mm}
			$
			128
			$ &
			$
			24
			$ &
			$
			21
			$ \\
			\vspace{4mm}
			$
			256
			$ &
			$
			27
			$ &
			$
			24
			$ \\
			\vspace{4mm}
			$
			512
			$ &
			$
			30
			$ &
			$
			27
			$ \\
			\vspace{4mm}
			$
			1024
			$ &
			$
			33
			$ &
			$
			30
			$\\
			\vspace{4mm}
			$
			2048
			$ &
			$
			36
			$ &
			$
			33
			$ \\
			\vspace{4mm}
		\end{tabular}
	\end{center}
\end{table}
\newpage
Из таблиц \ref{tabular:sr2}, \ref{tabular:sr3} видно, что количество сравнений при отсутствии элемента в массиве больше.
Также можно заметить, что количество сравнений при поиске в AVL--дереве больше, чем при бинарном поиске.
\section*{Вывод}
Из проведенного анализа можно сделать следующие выводы: количество сравнений при отсутствии элемента в массиве больше на 2. 
Количество сравнений при поиске в AVL--дереве больше, чем при бинарном поиске.


Следовательно наихудший вариант развития событий -- отсутствие элемента в массиве, при этом элемент должен быть вне диапазона чисел, присутствующих в массиве.
