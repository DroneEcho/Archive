\chapter{Аналитическая часть}
В данном разделе будут представлены теоретические сведения о рассматриваемых алгоритов поиска в словаре.\\

Словари – объекты, записанные парой "ключ-значение". Отличным примером словаря является толковый словарь. В данном словаре ключи – это нужное нам слово, а значения – это значение искомого слова. Ключи в словаре должны быть уникальными. Поиск необходимой информации в словаре – одна из фундаментальных задач программирования.


\section{Бинарный поиск}

Данный алгоритм базируется на том, что словарь изначально упорядочен, что позволяет сравнивать ключ с средним элементом, и, если, он меньше, то продолжать искать в левой части, таким же методом, иначе - в правой.\\

Алгоритм бинарного поиска можно описать следующим образом: 

\begin{enumerate}
	\item получить значение находящееся в середине словаря и сравнить его с ключом;
	\item в случае, если ключ меньше данного значения, продолжить поиск в младшей части словаря, в обратном случае -- в старшей части словаря;
	\item на новом интервале снова получить значение из середины этого интервала и сравнить с ключом.
	\item поиск продолжать до тех пор, пока не будет найден искомый ключ, или интервал поиска не окажется пустым.
\end{enumerate}

Обход словаря данным алгоритм можно представить в виде дерева, поэтому трудоемкость в худшем случае составит $\log_{2}{N}$.


\section{Поиск в АВЛ--Дереве}

АВЛ--дерево -- это прежде всего двоичное дерево поиска, ключи которого удовлетворяют стандартному свойству: ключ любого узла дерева не меньше любого ключа в левом поддереве данного узла и не больше любого ключа в правом поддереве этого узла. Это значит, что для поиска нужного ключа в АВЛ-дереве можно использовать стандартный алгоритм.


Особенностью АВЛ--дерева является то, что оно является сбалансированным в следующем смысле: для любого узла дерева высота его правого поддерева отличается от высоты левого поддерева не более чем на единицу.


Алгоритм поиска в АВЛ--дереве состоит из следующих шагов:
\begin{enumerate}
	\item Начинаем с корня дерева.
	\item. Если ключ, который мы ищем, равен ключу текущего узла, то мы нашли элемент и возвращаем его.
	\item Если ключ меньше ключа текущего узла, то мы переходим к левому поддереву и повторяем шаги 2-3 для этого поддерева.
	\item Если ключ больше ключа текущего узла, то мы переходим к правому поддереву и повторяем шаги 2-3 для этого поддерева.
	\item Если мы дошли до конца дерева и не нашли элемент, то элемент не существует в дереве.
\end{enumerate}
\section*{Вывод}

В данном разделе были рассмотрены алгоритмы поиска в словаре.
