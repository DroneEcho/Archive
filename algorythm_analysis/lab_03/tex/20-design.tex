\chapter{Конструкторская часть}
В этом разделе приведены схемы алгоритмов сортировки: плавная (smoothsort), сортировка перемешиванием и сортировка Шелла. Проведен анализ трудоемкости данных алгоритмов. Приведены требования к программному обеспечению.

\section{Разработка алгоритмов}

На рисунке 2.1 приведена схема алгоритма плавной сортировки (smoothsort).
На рисунке 2.2 приведена схема алгоритма сортировки перемешиванием.
На рисунке 2.3 приведена схема алгоритма сортировки Шелла.



\svgimg{200mm}{diag-shaker}{Cхема алгоритма сортировки перемешиванием}
\svgimg{200mm}{diag-smooth}{Cхема алгоритма плавной сортировки (smoothsort)}
\svgimg{200mm}{diag-shell}{Cхема алгоритма сортировки Шелла}
\newpage
%вместо break флаг выхода из цикда
% while не так пишется
\section{Требования к вводу}
К вводу программы прилагаются следующие требования.
\begin{enumerate}
	\item Перед вводом массива запрашиваются его размерность.
	\item На вход подается строка из чисел.
	\item Считываются числа типа int.
\end{enumerate}

\section{Требования к программе}
К программе предъявляется требования:
на выходе программы — массив с результатом сортировки исходного массива.

\section{Трудоемкость алгоритмов}
Трудоемкость вычисляется на основании следующей модели вычислений:
\begin{enumerate}
	\item  бзовые операции, имеющие стоимость 1 — +, -, *, /, =, ==, <=, >=, !=, +=, [ ], получение полей класса;
	\item трудоемкость оператора выбора \code{if условие then A else B} рассчитывается, как (\ref{for:if});
	\begin{equation}
		\label{for:if}
		f_{if} = f_{\text{условия}} +
		\begin{cases}
			f_A, & \text{если условие выполняется,}\\
			f_B, & \text{иначе.}
		\end{cases}
	\end{equation}
	\item трудоемкость цикла рассчитывается, как (\ref{for:cycle});
	\begin{equation}
		\label{for:cycle}
		f_{for} = f_{\text{инициализации}} + f_{\text{сравнения}} + N(f_{\text{тела}} + f_{\text{инкремент}} + f_{\text{сравнения}})
	\end{equation}
	\item стоимость условного перехода равна 0, стоимость вычисления условия остаётся.
\end{enumerate}

\subsection{Плавная сортировка}

Данные о трудоемкости плавной сортировки были взяты из источника [\ref{lib:smooth}].


\textbf{Лучший случай}: массив отсортирован; сортировка кучи во вложенном цикле не происходит.


Трудоемкость: $O(n)$


\textbf{Худший случай:} массив отсортирован в обратном порядке; вложенный цикл отсортирует всю кучу.


Трудоемкость: $O(n\log{n})$
\subsection{Сортировка перемешиванием}
\textbf{Лучший случай}: массив отсортирован; не произошло ни одного обмена за 1 проход -> выход из цикла


\textbf{Худший случай}: массив отсортирован в обратном порядке; в каждом случае происходил обмен, все внутренние циклы будут состоять из |left - right| итераций, где left, right -- индексы переменных, которые являются границей сортируемой части массива в очередном цикле.


Трудоёмкость сравнения внешнего цикла $while(swap == True)$ равна (\ref{for:outer_cycle}):
\begin{equation}
	\label{for:outer_cycle}
	f_{outer} = 1 + 2 \cdot (N - 1)
\end{equation}
Суммарная трудоёмкость внутренних циклов, количество итераций которых меняется в промежутке $[1..N-1]$, равна (\ref{for:bubble_inner}):
\begin{equation}
	\label{for:bubble_inner}
	f_{inner} = 5(N - 1) + \frac{2 \cdot (N - 1)}{2} \cdot (3 + f_{if})
\end{equation}
Трудоёмкость условия во внутреннем цикле равна (\ref{for:bubble_if}):
\begin{equation}
	\label{for:bubble_if}
	f_{if} = 4 + \begin{cases}
		0, & \text{лучший случай,}\\
		9, & \text{худший случай.}\\
	\end{cases}
\end{equation}

Трудоёмкость в лучшем случае (\ref{for:shaker_best}):
\begin{equation}
	\label{for:shaker_best}
	f_{best} = -3 + \frac{3}{2} N \approx \frac{3}{2} N = O(N)
\end{equation}

Трудоёмкость в худшем случае (\ref{for:shaker_worst}):
\begin{equation}
	\label{for:shaker_worst}
	f_{worst} = -3 - 8N + 8N^2 \approx 8N^2 = O(N^2)
\end{equation}

\subsection{Сортировка Шелла}
% рассчитать полную сортировку
\textbf{Лучший случай}: Массив отсортирован; обмена не происходит во внутреннем цикле и он завершается на первой итерации при каждом вызове; 


\textbf{Худший случай}: Массив отсортирован в обратном порядке; Неверно выбраны промежутки; Во внутреннем цикле каждый раз происходит сдвиг по шагу;


Трудоемкость в лучшем случае выведена формуле (\ref{сomplexity:shell_best}).
\begin{equation}
	\label{сomplexity:shell_best}
	\begin{gathered}
		f_{best} = 3 + 4 + \frac{N}{4} \cdot (3 + 2 + log(N) \cdot (2 + 4 + 4)) = \\
		= 7 + \frac{5N}{4} + \frac{5N \cdot log(N)}{2} = O(N \cdot log(N))
	\end{gathered}
\end{equation}

Трудоемкость в худшем случае выведена формуле (\ref{сomplexity:shell_worst}).
\begin{equation}
	\label{сomplexity:shell_worst}
	\begin{gathered}
		f_{worst} = 7 + \frac{N}{4} \cdot (5 + log(N) \cdot (10 + log(N) \cdot (6 + 4))) =\\
		= 7 + \frac{5N}{4} + \frac{5N \cdot log(N)}{2} + \frac{5N \cdot log^2(N)}{2} = O(N \cdot log^2(N))
	\end{gathered}
\end{equation}
\newpage
\section*{Вывод}
На основе теоретических данных, полученных из аналитического раздела, были построены схемы требуемых алгоритмов, были приведены требования к программному обеспечению, была вычислена трудоемкость алгоритмов.
Таким образом, были получены следующие данные о трудоемкости:
\begin{itemize}
	\item Плавная сортировка: лучший -- $O(n)$, худший --  $O(n\log{n})$;
	\item Сортировка перемешиванием: лучший -- $O(n)$, худший -- $O(n^2)$; 
	\item Сортировка Шелла: лучший -- $O(n\log{n})$, худший -- $O(n\log^{2}n)$. 
\end{itemize}

