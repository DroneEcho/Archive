\chapter{Исследовательская часть}

В данном разделе будет приведена постановка замера времени и сравнительный анализ алгоритмов на основе полученных данных.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялся замер времени:

\begin{itemize}
	\item Операционная система: 64-разрядная операционная система, процессор x64.
	\item Память: 16 Гб.
	\item Процессор: Intel(R) Core(TM) i7--4700HQ CPU @ 2.40 ГГц.
\end{itemize}

Во время замера времени ноутбук был нагружен только встроенными приложениями окружения, а также непосредственно системой тестирования.

\section{Время выполнения алгоритмов}

Алгоритмы замерялись при помощи функции $time.perf\_counter()$ из библиотеки $time$ языка $Python$. Данная функция возвращает значение в долях секунды счетчика производительности, то есть часов с наибольшим доступным разрешением для измерения короткой длительности.

Замеры времени для каждого выполнения проводились 10 раз. В качестве результата взято среднее время работы алгоритма.


Как видно из замеров, эффективней всего работает алгоритм, использующий 16 потоков.


При рассмотрении работы алгоритма с 16, 32 и 64 потоками на рисунке \ref{img:6} становится заметно, что разница между затраченным временем между 16 потоками и 32, 64 не превышает 
0.2 секунд. Разница в работе алгоритма с 32 и 64 потоками на рисунке \ref{img:last} не превышает 0.05 секунд. Также стоит учесть, что одновременное выполнение большого количества потоков может тратить много процессорного времени на переключение контекста за счет фактической обработки, сбрасывая блоки памяти в файловую систему и увеличивая количество операций ввода/вывода, что в конечном итоге замедляет работу всего приложения и засоряет хост-машину\ref{lib:proc}.


Также возникает проблема в работе с памятью. Все потоки используют одну и ту же память процесса, но если каждый поток требует больше памяти, потоки будут ограничены памятью процесса\ref{lib:proc}. 


Для данного алгоритма в предоставленной системе оптимальней всего будет использовать 16-поточный алгоритм. 
\img{100mm}{6_threads}{Замеры времени для последовательного алгоритма Бойера--Мура в сравнении с алгоритмом, использующим потоки\label{img:6}}

\img{100mm}{last}{Замеры времени для последовательного алгоритма Бойера--Мура в сравнении с алгоритмом, использующим потоки\label{img:last}}

\newpage
\section*{Вывод}
Из проведенного анализа можно сделать следующие выводы: использование многопоточности дает существенный прирост эффективности. Однако, при использовании большего количества потоков(более 16), прирост эффективности падает до несущественных размеров. Для устройства, на котором проводился  эксперимент, оптимальное количество потоков для эффективной работы был выбран 16-поточный алгоритм.

