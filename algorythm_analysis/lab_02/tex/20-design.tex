\chapter{Конструкторская часть}
В этом разделе будут приведены схемы алгоритмов умножения матриц: обычный, алгоритм Копперсмита -- Винограда, оптимизированный алгоритм Копперсмита -- Винограда. Проведен анализ трудоемкости данных алгоритмов.

\section{Разработка алгоритмов}

На рисунке 2.1 приведена схема алгоритма обычного нахождения матриц.
На рисунке 2.2 приведена схема алгоритма Копперсмита -- Винограда нахождения матриц.
На рисунке 2.3 приведена схема алгоритма оптимизированного Копперсмита -- Винограда нахождения матриц.

\svgimg{160mm}{diag-normal_matr}{Схема матричного алгоритма нахождения расстояния Левенштейна}
\svgimg{100mm}{diag-Vinograd}{схема алгоритма Копперсмита -- Винограда нахождения матриц}
\svgimg{100mm}{diag-Vinograd_opt}{схема алгоритма оптимизированного Копперсмита -- Винограда нахождения матриц}
\newpage

\section{Трудоемкость алгоритмов}
Трудоемкость рассчитывается следующим образом:
\begin{enumerate}
	\item Операции из следующего списка имеют трудоемкость 1.
	\begin{equation}
		+, -, ==, !=, <, >, <=, >=, [], ++, {-}-
	\end{equation}
	
	
	
	Операции из следующего списка имеют трудоемкость 2.
	\begin{equation}
		*, / ,\%, *=, /=, \%=
	\end{equation}
	\item Трудоемкость оператора выбора if условие then A else B рассчитывается, как:
	\begin{equation}
		\label{for:if}
		f_{if} = f_{\text{условия}} +
		\begin{cases}
			f_A, & \text{если условие выполняется,}\\
			f_B, & \text{иначе.}
		\end{cases}
	\end{equation}
	\item Трудоемкость цикла рассчитывается, как:
	\begin{equation}
		\label{for:for}
		f_{for} = f_{\text{инициализации}} + f_{\text{сравнения}} + N(f_{\text{тела}} + f_{\text{инкремента}} + f_{\text{сравнения}})
	\end{equation}
	
	где N - количество итераций цикла.
\end{enumerate}
Представим в вычислениях: 


Размер первой матрицы -- ($n_1$, $m_1$), размер второй матрицы -- ($m_1$, $m_2$).
\subsection{Обычный алгоритм умножения матриц}

Трудоёмкость стандартного алгоритма рассчитывается как:
\begin{equation}
	\label{standart}
	\begin{aligned}
	f_{basic\_alg} = 2 + n_{1}(2 + 2 + m_{2}(2 + 2 + m_{1}(2 + 10))) =\\ 12m_{1}m_{2}n_{1} + 4m_{2}n_{1} + 4n_{1} + 2.
	\end{aligned}
\end{equation}

\subsection{Алгоритм Винограда}

Трудоёмкость алгоритма Винограда является суммой трудоёмкостей следующих действий:
\begin{enumerate}
	
	\item Заполнения массива rowCnt:
	\begin{equation}
		f_{rowCnt} = 2 + n_{1}(2 + 2 + \frac{m_{1}}{2}(2 + 12)) = 7m_{1}n_{1} + 4n_{1} + 2.
	\end{equation}
	
	\item Заполнения массива colCnt:
	\begin{equation}
		f_{colCnt} = 2 + m_{2}(2 + 2 + \frac{m_{1}}{2}(2 + 12)) = 7m_{1}m_{2} + 4n_{1} + 2.
	\end{equation}
	
	\item Основного цикла заполнения матрицы:
	\begin{equation}
		\begin{aligned}
		f_{cycle} = 2 + n_{1}(2 + 2 + m_{2}(2 + 2 + 7 + \frac{m_{1}}{2}(2 + 23))) =\\ 12.5m_{1}cn_{1} + 11m_{2}n_{1} + 4n_{1} + 2.
	\end{aligned}
	\end{equation}
	
	\item Цикла для дополнения умножения, если $m_{1}$ нечётный:
	\begin{equation}
		\small
		f_{last} = \begin{cases}
			2, & \text{$m_{1}$ чётный,}\\
			2 + 2 + n_{1}(2 + 2 + c(2 + 13)) = 15m_{2}n_{1} + 4n_{1} + 4, & \text{иначе.}
		\end{cases}
	\end{equation}
\end{enumerate}

Итак, для лучшего случая ($m_{1}$ чётный): 
\begin{eqnarray}
	\label{stand:best}
	\begin{aligned}
	f_{vin\_b} = 7m_{1}n_{1} + 4n_{1} + 2 + 7m_{1}m_{2} + 4n_{1}\\ + 2 + 12.5m_{1}m_{2}n_{1} + 11m_{2}n_{1} + 4n_{1} + 2 + 2 =\\ 
	 12.5m_{1}m_{2}n_{1} + 7m_{1}n_{1} + 7m_{1}m_{2} + 11m_{2}n_{1} + 12n_{1} + 8.
	\end{aligned}
\end{eqnarray}

Для худшего случая ($m_{1}$ нечётный): 
\begin{eqnarray}
	\label{stand:worst}
	\begin{aligned}
	f_{vin\_w} = 7m_{1}n_{1} + 4n_{1} + 2 + 7m_{1}m_{2} + 4n_{1}\\ + 2 + 12.5m_{1}m_{2}n_{1} + 11m_{2}n_{1} + 4n_{1} + 2 + 15m_{2}n_{1} + 4n_{1} + 4 =\\ = 12.5m_{1}m_{2}n_{1} + 7m_{1}n_{1} + 7m_{1}c + 26m_{2}n_{1} + 16n_{1} + 10.
	\end{aligned}
\end{eqnarray}

\subsection{Оптимизированный алгоритм Винограда}

Трудоёмкость оптимизированного алгоритма Винограда является суммой трудоёмкостей следующих последовательно выполненных действий.
\begin{enumerate}
	\item Заполнения массива rowCnt:
	\begin{equation}
		f_{rowCnt} = 2 + n_{1}(2 + 2 + \frac{m_{1}}{2}(3 + 12)) = 7.5m_{1}n_{1} + 4n_{1} + 2.
	\end{equation}
	
	\item Заполнения массива colCnt:
	\begin{equation}
		f_{colCnt} = 2 + m_{2}(2 + 2 + \frac{m_{1}}{2}(3 + 12)) = 7.5m_{1}m_{2} + 4n_{1} + 2.
	\end{equation}
	
	\item Основного цикла заполнения матрицы:
	\begin{equation}
		\begin{aligned}
		f_{cycle} = 2 + n_{1}(2 + 2 + m_{2}(2 + 2 + 7 + \frac{m_{1}}{2}(2 + 23))) = \\12.5m_{1}m_{2}n_{1} + 11m_{2}n_{1} + 4n_{1} + 2.
		\end{aligned}
	\end{equation}
	
	\item Цикла для дополнения умножения, если $m_{1}$ нечётный:
	\begin{equation}
		\small
		f_{last} = \begin{cases}
			2, & \text{$m_{1}$ чётный,}\\
			\begin{aligned}2 + 2 + n_{1}(2 + 2 + m_{2}(2 + 13)) =\\ 15m_{2}n_{1} + 4n_{1} + 4, & \text{иначе.}
			\end{aligned}
		\end{cases}
	\end{equation}
\end{enumerate}

Итак, для лучшего случая ($m_{1}$ чётный): 
\begin{eqnarray}
	\label{opt:best}
	\begin{aligned}
	f_{vinOpt\_b} = 7.5m_{1}n_{1} + 5n_{1} + 5 + 7.5m_{1}m_{2} + 5n_{1}\\ + 2 + 9m_{1}m_{2}n_{1} + 12m_{2}n_{1} + 4n_{1} + 5 =\\ 9m_{1}m_{2}n_{1} + 7.5m_{1}n_{1} + 7.5m_{1}m_{2} + 12m_{2}n_{1} + 14n_{1} + 12.
\end{aligned}
\end{eqnarray}

Для худшего случая ($m_{1}$ нечётный): 
\begin{eqnarray}
	\label{opt:worst}
	\begin{aligned}
	f_{vinOpt\_w} = 7.5m_{1}n_{1} + 5n_{1} + 5 + 7.5m_{1}m_{2} + 5n_{1}\\ + 2 + 9m_{1}m_{2}n_{1} + 12m_{2}n_{1} + 9m_{2}n_{1} + 4n_{1} + 5 =\\ 9m_{1}m_{2}n_{1} + 7.5m_{1}n_{1} + 7.5m_{1}m_{2} + 21m_{2}n_{1} + 14n_{1} + 12.
\end{aligned}
\end{eqnarray}
\section*{Вывод}
На основе теоретических данных, полученных из аналитического раздела, были построены схемы требуемых алгоритмов, были вычислены трудоемкость стандартного алгоритма умножения матриц \ref{standart}, алгоритмов Винограда стандартного и оптимизированного соответственно в худших \ref{stand:worst}, \ref{opt:worst}  и лучших \ref{stand:best}, \ref{opt:best} случаях. Исходя из результатов анализа трудоемкости оптимизированный алгоритм Винограда должен работать быстрее стандартного, алгоритм стандартного умножения матриц будет работать медленней всего. 


