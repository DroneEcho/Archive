\chapter{Исследовательская часть}

В данном разделе будут приведены постановка эксперимента и сравнительный анализ алгоритмов на основе полученных данных.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item Операционная система: 64-разрядная операционная система, процессор x64.
	\item Память: 16 Гб.
	\item Процессор: Intel(R) Core(TM) i7--4700HQ CPU @ 2.40 ГГц.
\end{itemize}

Во время тестирования ноутбук был нагружен только встроенными приложениями окружения, а также непосредственно системой тестирования.

\section{Расчет затрат памяти}
Пусть (n1, m1) -- размеры первой матрицы, (m1, m2) -- размеры второй матрицы.


Стандартный алгоритм перемножения матриц:
		
		
		-- Матрица 1 -- n1 * m1 * sizeof(int);
		
		
		-- Матрица 2 -- m1 * m2 * sizeof(int);
		
		
		-- Переменные с размером матриц -- 3 * sizeof(int).


Алгоритм Винограда, оптимизированный алгоритм Винограда перемножения матриц:


		-- Матрица 1 -- n1 * m1 * sizeof(int);


		-- Матрица 2 -- m1 * m2 * sizeof(int);


		-- Переменные с размером матриц -- 3 * sizeof(int);


		-- Вектор RowCnt -- n1 * sizeof(int);


		-- Вектор ColCnt -- m2 * sizeof(int).


В итоге, алгоритм Винограда занимает больше памяти из-за использования дополнительных векторов при вычислении.
\section{Время выполнения алгоритмов}

Алгоритмы тестировались при помощи функции clock() из библиотеки <time.h> языка C. Данная функция возвращает реальное время с момента инициализации текущего процессора, типа long в секундах.

Замеры времени для каждого перемножения матриц проводились 100 раз. В качестве результата взято среднее время работы алгоритма.

Результаты замеров при четных размерах матриц приведены в таблице \ref{tab:time} (время в мс.).


Результаты замеров при нечетных размерах матриц приведены в таблице \ref{tab:time2} (время в мс.).
\begin{table}[!ht]
	\captionsetup{singlelinecheck=off}
	\caption{\raggedright\label{tab:time}Результаты замеров времени при четных размерах(мс.)}
	\begin{tabular}{|c|p{3cm}|p{3cm}|p{4.2cm}|
		}
		
		\hline
		Размерность матриц & Стандартный алгоритм& Алгоритм Винограда & Оптимизированный Алгоритм Винограда\\
		\hline
		50x50 & 0.000630 & 0.000460 & 0.000370 \\
		\hline
		100x100 & 0.004320 & 0.003520 &0.003130 \\
		\hline
		150x150 & 0.013970 & 0.011710 & 0.010700 \\
		\hline
		200x200 & 0.033100 & 0.027740 & 0.025190 \\
		\hline
		250x250 & 0.065670 & 0.056320 & 0.050710 \\
		\hline
		300x300 & 0.123230 & 0.104490 & 0.093440 \\
		\hline
	\end{tabular}
\end{table}

\begin{table}[!ht]
	\captionsetup{singlelinecheck=off}
	\caption{\raggedright\label{tab:time2}Результаты замеров времени при нечетных размерах(мс.)}
	\begin{tabular}{|c|p{3cm}|p{3cm}|p{4.2cm}|
		}
		
		\hline
		Размерность матриц & Стандартный алгоритм& Алгоритм Винограда & Оптимизированный Алгоритм Винограда\\
		\hline
		51x51 & 0.000550 & 0.000510 & 0.000450 \\
		\hline
		101x101 & 0.004420 & 0.003780 &0.003360 \\
		\hline
		151x151 & 0.014270 & 0.012070 & 0.010940 \\
		\hline
		201x201 & 0.033960 & 0.028630 & 0.026120 \\
		\hline
		251x251 & 0.066540 & 0.057090 & 0.051110 \\
		\hline
		301x301 & 0.125730 & 0.109090 & 0.097860 \\
		\hline
	\end{tabular}
\end{table}
\newpage
\section*{Вывод}

Алгоритм Копперсмита - Винограда имеет меньшую трудоемкость и выполняется в среднем в 1.3 раза быстрее, чем обычный алгоритм умножения матриц. Учлучшенный алгоритм Копперсмита - Винограда работает в 1.5 раз быстрее cтандартного умножения матриц и в 1.2 быстрее оригинального алгоритма Винограда.