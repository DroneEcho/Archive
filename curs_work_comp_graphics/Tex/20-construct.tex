\chapter{Конструкторский раздел}
В этом разделе будет рассмотрена аппроксимация трёхмерных объектов, описаны трёхмерные преобразования, приведены схемы разрабатываемых алгоритмов, описаны входные данные.
\section{Аппроксимация трехмерных объектов}
Так как пользователь должен иметь возможность составить модель для просмотра и может в любой момент изменить параметры объектов, то нужно предусмотреть, чтобы аппроксимация происходила автоматически. Для цилиндра и конуса нужно выполнить следующие действия:
\begin{enumerate}
\item Выбрать требуемое количество разбиений N для тела вращения.
\item Подсчитать из этого угол поворота радиуса вектора для расчёта количества требуемых треугольников.
\item Вычислить координаты следующей вершины на окружности по формуле:
\begin{align}
	\begin{gathered}
	X = X_0 * R\cos(a * i)\\
	Y = Y_0\\
	Z = Z_0 * R\sin(a * i)
	\end{gathered}
\end{align}
\item Итоговая аппроксимация зависит от конкретного тела вращения. Для конуса: полученные точки соединяются с вершиной. Для цилиндра: из полученных точек получается прямоугольник.
\end{enumerate}
Алгоритм аппроксимации сферы сложнее. В программе будет генерироваться икосфера – это многогранная сфера, состоящая из треугольников. Её преимущества в том, что она изотропна – то есть свойства тела
по всем направлениям меняться не будут. Кроме того, распределение треугольников будет равномерней, чем в других вариантах разбиения, что не будет приводить к странностям у полюсов сферы. Поэтому алгоритм будет
следующий:
\begin{enumerate}
\item На основе информации о сфере построить правильный икосаэдр, который состоит из 20 граней и 30 ребер.

\item Итеративно каждый треугольник икосаэдра делить на четыре одинаковых треугольника. Координаты средней точки треугольника корректируются так, чтобы она лежала на сфере. Процесс повторять до тех пор, пока не будет достигнута требуемая величина аппроксимации.
\end{enumerate}
На рисунке \ref{sph} представлен процесс итеративного приближения икосаэдра к сфере:
\img{40mm}{sphere}{\label{sph}Процесс итеративного приближения икосаэдра к сфере}

Для того, чтобы икосаэдр был сгенерирован правильно, нужно, чтобы средняя точка треугольника вычислялась с коррекцией. Пусть координаты средней точки треугольника – ($X_0, Y_0, Z_0$), тогда коррекция будет выполняться по формуле:
\begin{align}
	\begin{gathered}
	L =\sqrt{X_0^2 + Y_0^2 + Z_0^2}\\
	X_1 =\frac{X_0}{L}\\
	Y_1 =\frac{Y_0}{L}\\
	Z_1 =\frac{Z0}{L}
	\end{gathered}
\end{align}
\section{Описание трехмерных преобразований}
\subsection{Способ хранения декартовых координат}
Для хранения координат точек будет применяться вектор-столбец,
состоящий из четырех координат: x, y, z, w, причем w по умолчанию равна 1. Это сделано для комфортного умножения вектора на матрицы трансформации, которые имеют размерность 4x4.
\subsection{Преобразование трехмерных координат в двухмерное пространство}
Экран располагает только двумя координатами, потому необходимо выбрать способ, с помощью которого нужно переносить трехмерные объекты на двухмерное пространство. Любой пиксель имеет определенный цвет, и за счет этого необходимо разрешить проблему передачи объемности и реалистичности изображения.
Алгоритм приведения координат к нужному виду следующий:
\begin{enumerate}
\item Перевести объект из собственного пространства в мировое.
\item Перевести объект из мирового пространства в пространство камеры.
\item Найти все проекции точек из пространства камеры в видимые точки, где координаты точек x, y , z находятся в диапазоне [-w, w], а w находится в диапазоне [0, 1].
\item Масштабировать все точки, полученные в п.3, на картинку необходимого разрешения.
\end{enumerate}
Чтобы выполнить все преобразования, нужно использовать матрицы преобразований. Сначала вычисляются все необходимые матрицы, затем они перемножаются в нужном порядке. Исходные координаты умножаются на получившийся результат, в результате чего координаты приводятся к нужной системе.
\subsection{Преобразования трехмерной сцены в пространство камеры}
Чтобы привести трехмерную сцену к пространству камеры, нужно выполнить операцию умножения для каждой вершины всех полигональных моделей на матрицу камеры.


Как правило, матрица камеры определяется с помощью параметров, которые зависят от трехмерного положения камеры. Т.е параметров камеры, таких как ее положение и ориентации. Положение камеры задается точкой в трехмерном пространстве, а ориентация определяется матрицей поворота.


После того, как матрица камеры определена, каждая вершина в сцене умножается на эту матрицу, чтобы получить ее координаты в пространстве камеры. Это позволяет отобразить трехмерную сцену на двумерном экране.

Пусть:
$\alpha$ – координаты точки в пространстве, на которую смотрит камера,

$\beta$ – вектор, который указывает, куда смотрит верх камеры, 

$\Psi$– ортогональный вектор к векторам направления взгляда и вектору направления.

Тогда матрица будет выглядеть так:

\begin{align}
	A = 
	\begin{pmatrix}	
	\alpha_x & \beta_x & \Psi_x & 0 \\
	\alpha_y & \beta_y & \Psi_y & 0\\
	\alpha_z & \beta_z & \Psi_z & 0\\
	-(P * \alpha) & -(P * \beta) & -(P * \Psi) & 1
	\end{pmatrix}
\end{align}
\subsection{Матрица перспективной проекции}
Матрица проекции используется для преобразования координат вершин из пространства камеры в пространство отсечения. Пространство отсечения является усеченной пирамидой, которая представляет область пространства, которая может быть видна из камеры. Диапазон усеченной пирамиды зависит от параметров камеры, таких как угол обзора и соотношение сторон экрана.


После преобразования координат вершин в пространство отсечения, значения координат x, y и z будут находиться в диапазоне от -w до w, где w - это компонента, которая отвечает за перспективное искажение. Значение w для каждой вершины зависит от ее расстояния от камеры. Чем дальше от камеры находится вершина, тем больше будет значение w, что приведет к ее сжатию вдоль оси z в пространстве отсечения. Все вершины, находящиеся вне диапазона [-w, w] будут отсечены.


Пусть: 


AR – отношение ширины изображения к его высоте, 


$\alpha$ – угол обзора камеры, 


$Z_n$ -- координата z ближайшей к камере плоскости отсечения пирамиды видимости, 


$Z_f$ -- координата z дальней от камеры плоскости отсечения пирамиды видимости. 


Тогда матрица перспективной проекции принимает вид:

\begin{align}
	A = 
	\begin{pmatrix}	
		\frac{\cot{\frac{\alpha}{2}}}{AR} & 0 & 0 & 0 \\
		0 & \cot{\frac{\alpha}{2}} & 0 & 0\\
		0 & 0 & \frac{Z_f \times Z_n}{Z_f - Z_n} & 1\\
		0 & 0 & \frac{Z_f}{Z_f - Z_n} & 0
	\end{pmatrix}
\end{align}

Следующий этап – спроецировать все координаты на одну плоскость, разде-
лив всё на координату z. После умножения вектора координат на матрицу
перспективной проекции, реальная координата z заносится в w-компоненту,
так что вместо деления на z делят на w.
\subsection{Преобразования трёхмерной сцены в пространство области изображения}
\section{Алгоритм Z-буфера}
Алгоритм Z-буфера используется в первом режиме работы программы. Совместно с алгоритмом Z-буфера применяется для закраски метод Гуро, модель Ламберта используется в качестве модели освещения.
На рисунке изображена схема алгоритма Z-буфера с применением метода Гуро для закраски:
\section{Алгоритм обратной трассировки лучей}
Алгоритм обратной трассировки лучей используется во втором режиме работы программы для построения реалистического изображения. Совместно с ним используется модель освещения Уиттеда.


В рамках алгоритма обратной трассировки лучей, для каждого пикселя на экране, создается луч, направленный вдоль зрительного луча, проходящего через этот пиксель. Затем, для каждого луча рассчитывается пересечение со сценой и определяется точка, в которой луч попадает на поверхность объекта.


Далее, в зависимости от свойств поверхности, на которую был направлен луч, рассчитывается вклад в светосильность от отражения и рассеяния света. Формулы Уиттеда для расчета коэффициентов отражения и рассеяния определяются в зависимости от типа поверхности.


Когда вклад от освещения рассчитан, луч продолжает свой путь, отражаясь или преломляясь в зависимости от свойств материала, пока он не попадет на источник света. Таким образом, алгоритм обратной трассировки лучей учитывает сложное взаимодействие света и объектов, что позволяет получить реалистичное изображение трехмерной сцены.

Отражённый луч можно найти, зная направление падающего луча и нормаль к поверхности.
Пусть:


 $\vec L$ – направление луча, 
 
 
 $\vec n$ – нормаль к поверхности. 
 
 
Луч можно разбить на две части: , $\vec L_p$ которая перпендикулярна нормали, и $\vec L_n$ -- параллельна нормали.


Представленная ситуация изображена на рисунке \ref{vec}

\img{40mm}{vec1tras}{\label{vec}Рассматриваемые векторы для расчёта отражённого луча}


Учитывая свойства скалярного произведения $\vec L_n = \vec n * (\vec n,\vec  L)$ и $\vec L_p = \vec L - \vec n * (\vec n, \vec L)$ так как отражённый луч выражается через разность этих векторов, то отражённый луч выражается по формуле:
\begin{align}
R = 2 *\vec  n * (\vec n, \vec L) - \vec L
\end{align}
По закону преломления падающий, преломлённый луч и нормаль к поверхности лежат в одной плоскости. Пусть:


$\mu_i$ – показатели преломления сред, 


$\eta_i$ – углы падения и отражения света. 


Применяя закон Снеллиуса, параметры преломлённого луча можно вычислить по формуле:
\begin{align}
	\begin{gathered}
R = \frac{\mu_1}{\mu_2}\vec L + (\frac{\mu_1}{\mu_2}\cos(\eta_1) - \cos(\eta_2)) \vec n\\
\cos(\eta_2) = \sqrt{1 - (\frac{\mu_1}{\mu_2})^2 * (1 - \cos(\eta_1))^2}
	\end{gathered}
\end{align}

На рисунке приведена схема алгоритма обратной трассировки лучей:
\section{Алгоритм пересечения луча с параллелепипедом}

Алгоритм пересечения луча с параллелепипедом - это алгоритм, используемый в компьютерной графике для определения того, пересекает ли луч, исходящий из камеры, параллелепипед на своем пути.


При работе алгоритма обратной трассировки лучей крайне неэффективно при каждой трассировке луча искать пересечения со всеми полигонами каждого объекта в сцене, поэтому имеет смысл заключить объект в параллелепипед, который бы полностью его включал.


Алгоритм пересечения луча с параллелепипедом работает следующим образом: параллелепипед задаётся координатами двух вершин: с минимальными и максимальными значениями координат x, y, z. Таким образом это позволяет задать шесть плоскостей, ограничивающих параллелепипед, и при этом все они будут параллельны координатным плоскостям. Происходит проверка, пересекает ли луч плоскость параллелепипеда. Для этого используется формула пересечения луча с плоскостью, позволяющая определить расстояние от начала луча до точки пересечения.


Затем происходит проверка, находится ли эта точка пересечения внутри параллелепипеда. Для этого необходимо проверить, удовлетворяют ли координаты точки пересечения условиям нахождения внутри параллелепипеда. Если точка находится внутри параллелепипеда, то луч пересекает его, и требуемая информация может быть получена для дальнейшей обработки.


Если же точка находится вне параллелепипеда, то необходимо проверить пересечение с другими сторонами параллелепипеда. Это делается путем повторения процедуры пересечения луча с каждой из сторон, пока не будет найдена точка пересечения внутри параллелепипеда или не будут просмотрены все стороны.

\newpage
Рассмотрим пару плоскостей, параллельных плоскости yz: X = x1 и X = x2. Пусть:


D – вектор направления луча. 


Если координата x вектора D = 0, то заданный луч параллелен этим плоскостям, и, если x0 < x1 или x0 > x1, то он не пересекает рассматриваемый прямоугольный параллелепипед. Если же Dx не равно 0, то вычисляются отношения:
\begin{align}
	\begin{gathered}
	t_1x = \frac{x_1 - x_0}{D_x}\\
	t_2x = \frac{x_2 - x_0}{D_x}
	\end{gathered}
\end{align}
Можно считать, что найденные величины связаны неравенством $t_1x < t_2x$.


Пусть: 


$t_n = t_1x, t_f = t_2x$. 


Считая, что $D_y$ не равно нулю, и рассматривая вторую пару плоскостей, несущих грани заданного параллелепипеда, Y = $y_1$, Y = $y_2$, вычисляются величины:
\begin{align}
	\begin{gathered}
		t_1x = \frac{y_1 - y_0}{D_y}\\
		t_2x = \frac{y_2 - y_0}{D_y}
	\end{gathered}
\end{align}
Если $t_1y > t_n$, то тогда $t_n = t_1y$. Если $t_2y < t_f$, то тогда $t_f = t_2y$. При $t_n > t_f$ или при $t_f < 0$ заданный луч проходит мимо прямоугольного параллелепипеда.


Считая, что $D_z$ не равно нулю, и рассматривая вторую пару плоскостей, несущих грани заданного параллелепипеда, $Z = z_1, Z = z_2$, вычисляются величины:
\begin{align}
	\begin{gathered}
		t_1z = \frac{z_1 - z_0}{D_z}\\
		t_2z = \frac{z_2 - z_0}{D_z}
	\end{gathered}
\end{align}
и повторяются сравнения.
Если в итоге всех проведённых операций получается, что $0 < t_n < t_f$ или $0 < t_f$, то заданный луч пересечёт исходный параллелепипед со сторонами, параллельными координатным осям.


Следует отметить, что при пересечении лучом параллелепипеда извне знаки $t_n$ и $t_f$ должны быть равны, в противном случае можно сделать вывод, что луч пересекает параллелепипед изнутри.
\section{Описание входных данных}
В разработанной программе входные данные подаются в виде файла с расширением .obj. В этом формате помимо координат вершин можно передавать информацию о текстурах и нормалях.
Формат файла:
\begin{enumerate}
\item Список вершин с координатами (x, y, z)
\item Текстурные координаты (u, v)
\item Координаты нормалей (x, y, z)
\item Определение поверхности задаётся в формате i1/i2/i3, где i1 – индекс координаты вершины, i2 – индекс координаты текстуры, i3 – индекс координаты нормали
\end{enumerate}
\section{Вывод}
В этом разделе была рассмотрена аппроксимация трёхмерных объектов, описаны трёхмерные преобразования, приведены схемы разрабатываемых алгоритмов, описаны входные данные.